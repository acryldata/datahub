"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[22163],{15680:(e,t,a)=>{a.d(t,{xA:()=>p,yg:()=>g});var n=a(96540);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var o=n.createContext({}),d=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(o.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=d(a),m=i,g=u["".concat(o,".").concat(m)]||u[m]||c[m]||r;return a?n.createElement(g,s(s({ref:t},p),{},{components:a})):n.createElement(g,s({ref:t},p))}));function g(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,s=new Array(r);s[0]=m;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[u]="string"==typeof e?e:i,s[1]=l;for(var d=2;d<r;d++)s[d]=a[d];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},66682:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>g,frontMatter:()=>l,metadata:()=>d,toc:()=>u});a(96540);var n=a(15680);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))})),e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}const l={sidebar_position:24,title:"SchemaField",slug:"/generated/metamodel/entities/schemafield-datahub",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/schemaField-datahub.md"},o="SchemaField",d={unversionedId:"docs/generated/metamodel/entities/schemaField-datahub",id:"docs/generated/metamodel/entities/schemaField-datahub",title:"SchemaField",description:"The schemaField entity represents an individual column or field within a dataset's schema. While schema information is typically ingested as part of a dataset's schemaMetadata aspect, schemaField entities exist as first-class entities to enable direct attachment of metadata like tags, glossary terms, documentation, and structured properties at the field level.",source:"@site/genDocs/docs/generated/metamodel/entities/schemaField-datahub.md",sourceDirName:"docs/generated/metamodel/entities",slug:"/generated/metamodel/entities/schemafield-datahub",permalink:"/docs/generated/metamodel/entities/schemafield-datahub",draft:!1,editUrl:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/schemaField-datahub.md",tags:[],version:"current",sidebarPosition:24,frontMatter:{sidebar_position:24,title:"SchemaField",slug:"/generated/metamodel/entities/schemafield-datahub",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/schemaField-datahub.md"},sidebar:"overviewSidebar",previous:{title:"Test",permalink:"/docs/generated/metamodel/entities/test"},next:{title:"SchemaField",permalink:"/docs/generated/metamodel/entities/schemafield"}},p={},u=[{value:"Identity",id:"identity",level:2},{value:"Examples",id:"examples",level:3},{value:"Important Capabilities",id:"important-capabilities",level:2},{value:"Field Information (schemafieldInfo)",id:"field-information-schemafieldinfo",level:3},{value:"Documentation",id:"documentation",level:3},{value:"Tags",id:"tags",level:3},{value:"Glossary Terms",id:"glossary-terms",level:3},{value:"Business Attributes",id:"business-attributes",level:3},{value:"Structured Properties",id:"structured-properties",level:3},{value:"Field Aliases (schemaFieldAliases)",id:"field-aliases-schemafieldaliases",level:3},{value:"Deprecation",id:"deprecation",level:3},{value:"Logical Parent",id:"logical-parent",level:3},{value:"Forms",id:"forms",level:3},{value:"Status",id:"status",level:3},{value:"Test Results",id:"test-results",level:3},{value:"SubTypes",id:"subtypes",level:3},{value:"Code Examples",id:"code-examples",level:2},{value:"Querying a Schema Field via REST API",id:"querying-a-schema-field-via-rest-api",level:3},{value:"Working with Fine-Grained Lineage",id:"working-with-fine-grained-lineage",level:3},{value:"Integration Points",id:"integration-points",level:2},{value:"Relationship with Datasets",id:"relationship-with-datasets",level:3},{value:"Fine-Grained Lineage",id:"fine-grained-lineage",level:3},{value:"GraphQL API",id:"graphql-api",level:3},{value:"Search and Discovery",id:"search-and-discovery",level:3},{value:"Notable Exceptions",id:"notable-exceptions",level:2},{value:"Dual Access Patterns",id:"dual-access-patterns",level:3},{value:"Feature Flag Dependency",id:"feature-flag-dependency",level:3},{value:"Field Path Encoding",id:"field-path-encoding",level:3},{value:"V1 vs V2 Field Paths",id:"v1-vs-v2-field-paths",level:3},{value:"Technical Reference",id:"technical-reference",level:2}],c={toc:u},m="wrapper";function g(e){var{components:t}=e,a=s(e,["components"]);return(0,n.yg)(m,r(function(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{},n=Object.keys(a);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(a).filter((function(e){return Object.getOwnPropertyDescriptor(a,e).enumerable})))),n.forEach((function(t){i(e,t,a[t])}))}return e}({},c,a),{components:t,mdxType:"MDXLayout"}),(0,n.yg)("h1",{id:"schemafield"},"SchemaField"),(0,n.yg)("p",null,"The schemaField entity represents an individual column or field within a dataset's schema. While schema information is typically ingested as part of a dataset's ",(0,n.yg)("inlineCode",{parentName:"p"},"schemaMetadata")," aspect, schemaField entities exist as first-class entities to enable direct attachment of metadata like tags, glossary terms, documentation, and structured properties at the field level."),(0,n.yg)("p",null,"SchemaField entities are automatically created by DataHub when datasets with schemas are ingested. They serve as the link between dataset-level metadata and column-level metadata, enabling fine-grained data governance and lineage tracking at the field level."),(0,n.yg)("h2",{id:"identity"},"Identity"),(0,n.yg)("p",null,"SchemaField entities are uniquely identified by two components:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Parent URN"),": The URN of the dataset that contains this field"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Field Path"),": The path identifying the field within the schema (e.g., ",(0,n.yg)("inlineCode",{parentName:"li"},"user_id"),", ",(0,n.yg)("inlineCode",{parentName:"li"},"address.zipcode")," for nested fields)")),(0,n.yg)("p",null,"The URN structure for a schemaField follows this pattern:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre"},"urn:li:schemaField:(<parent_dataset_urn>,<encoded_field_path>)\n")),(0,n.yg)("h3",{id:"examples"},"Examples"),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"Simple field:")),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre"},"urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,public.users,PROD),user_id)\n")),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"Nested field:")),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre"},"urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:bigquery,project.dataset.table,PROD),address.zipcode)\n")),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"Field with special characters (URL encoded):")),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre"},"urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:snowflake,db.schema.table,PROD),first%20name)\n")),(0,n.yg)("p",null,"Note that the field path component may be URL-encoded if it contains special characters. The v1 field path uses ",(0,n.yg)("inlineCode",{parentName:"p"},".")," notation for nested structures, while v2 field paths include type information (e.g., ",(0,n.yg)("inlineCode",{parentName:"p"},"[version=2.0].[type=struct].address.[type=string].zipcode"),")."),(0,n.yg)("h2",{id:"important-capabilities"},"Important Capabilities"),(0,n.yg)("h3",{id:"field-information-schemafieldinfo"},"Field Information (schemafieldInfo)"),(0,n.yg)("p",null,"The ",(0,n.yg)("inlineCode",{parentName:"p"},"schemafieldInfo")," aspect contains basic identifying information about the schema field:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"name"),": The display name of the field"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"schemaFieldAliases"),": Alternative URNs for this field, used to store field path variations")),(0,n.yg)("p",null,"This aspect is primarily used internally by DataHub to support field path variations and search functionality."),(0,n.yg)("h3",{id:"documentation"},"Documentation"),(0,n.yg)("p",null,"The ",(0,n.yg)("inlineCode",{parentName:"p"},"documentation")," aspect stores field-level documentation from multiple sources. Unlike the dataset-level description pattern which uses separate aspects (",(0,n.yg)("inlineCode",{parentName:"p"},"datasetProperties")," and ",(0,n.yg)("inlineCode",{parentName:"p"},"editableDatasetProperties"),"), field-level documentation uses a single unified aspect that can contain multiple documentation entries from different sources."),(0,n.yg)("p",null,"Each documentation entry includes:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"The documentation text/description"),(0,n.yg)("li",{parentName:"ul"},"The source system or attribution information")),(0,n.yg)("details",null,(0,n.yg)("summary",null,"Python SDK: Add or update documentation for a schema field"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-python"},'import time\n\nimport datahub.emitter.mce_builder as builder\nimport datahub.metadata.schema_classes as models\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.ingestion.graph.client import DatahubClientConfig, DataHubGraph\n\ngms_endpoint = "http://localhost:8080"\nemitter = DatahubRestEmitter(gms_server=gms_endpoint, extra_headers={})\ngraph = DataHubGraph(DatahubClientConfig(server=gms_endpoint))\n\ndataset_urn = builder.make_dataset_urn(\n    platform="bigquery", name="project.dataset.transactions", env="PROD"\n)\n\nfield_urn = builder.make_schema_field_urn(\n    parent_urn=dataset_urn, field_path="transaction_amount"\n)\n\ncurrent_docs = graph.get_aspect(\n    entity_urn=field_urn, aspect_type=models.DocumentationClass\n)\n\ndocumentation_text = (\n    "The monetary value of the transaction in USD. "\n    "This field is calculated from the base currency amount "\n    "using the exchange rate at transaction time."\n)\n\nattribution = models.MetadataAttributionClass(\n    time=int(time.time() * 1000),\n    actor=builder.make_user_urn("data_steward"),\n    source=builder.make_data_platform_urn("manual"),\n)\n\nnew_doc = models.DocumentationAssociationClass(\n    documentation=documentation_text,\n    attribution=attribution,\n)\n\nif current_docs and current_docs.documentations:\n    source_exists = False\n    for i, doc in enumerate(current_docs.documentations):\n        if doc.attribution and doc.attribution.source == attribution.source:\n            current_docs.documentations[i] = new_doc\n            source_exists = True\n            break\n    if not source_exists:\n        current_docs.documentations.append(new_doc)\nelse:\n    current_docs = models.DocumentationClass(documentations=[new_doc])\n\nemitter.emit(\n    MetadataChangeProposalWrapper(\n        entityUrn=field_urn,\n        aspect=current_docs,\n    )\n)\n\n'))),(0,n.yg)("h3",{id:"tags"},"Tags"),(0,n.yg)("p",null,"Tags can be added directly to schema fields using the ",(0,n.yg)("inlineCode",{parentName:"p"},"globalTags")," aspect. This is separate from tags added at the dataset level, allowing for fine-grained classification of individual columns."),(0,n.yg)("p",null,"Tags on fields are commonly used to:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Mark sensitive data (PII, PHI, confidential)"),(0,n.yg)("li",{parentName:"ul"},"Indicate data quality issues"),(0,n.yg)("li",{parentName:"ul"},"Flag deprecated fields"),(0,n.yg)("li",{parentName:"ul"},"Classify data by security level or compliance requirements")),(0,n.yg)("details",null,(0,n.yg)("summary",null,"Python SDK: Add a tag to a schema field"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-python"},'import datahub.emitter.mce_builder as builder\nimport datahub.metadata.schema_classes as models\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.ingestion.graph.client import DatahubClientConfig, DataHubGraph\n\ngms_endpoint = "http://localhost:8080"\nemitter = DatahubRestEmitter(gms_server=gms_endpoint, extra_headers={})\ngraph = DataHubGraph(DatahubClientConfig(server=gms_endpoint))\n\ndataset_urn = builder.make_dataset_urn(\n    platform="postgres", name="public.users", env="PROD"\n)\n\nfield_urn = builder.make_schema_field_urn(\n    parent_urn=dataset_urn, field_path="email_address"\n)\n\ncurrent_tags = graph.get_aspect(\n    entity_urn=field_urn, aspect_type=models.GlobalTagsClass\n)\n\ntag_to_add = builder.make_tag_urn("PII")\ntag_association = models.TagAssociationClass(tag=tag_to_add)\n\nif current_tags and current_tags.tags:\n    if tag_to_add not in [tag.tag for tag in current_tags.tags]:\n        current_tags.tags.append(tag_association)\nelse:\n    current_tags = models.GlobalTagsClass(tags=[tag_association])\n\nemitter.emit(\n    MetadataChangeProposalWrapper(\n        entityUrn=field_urn,\n        aspect=current_tags,\n    )\n)\n\n'))),(0,n.yg)("h3",{id:"glossary-terms"},"Glossary Terms"),(0,n.yg)("p",null,"Glossary terms can be attached to schema fields via the ",(0,n.yg)("inlineCode",{parentName:"p"},"glossaryTerms")," aspect, enabling semantic annotation at the column level. This helps users understand the business meaning of individual fields."),(0,n.yg)("details",null,(0,n.yg)("summary",null,"Python SDK: Add a glossary term to a schema field"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-python"},'import datahub.emitter.mce_builder as builder\nimport datahub.metadata.schema_classes as models\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.ingestion.graph.client import DatahubClientConfig, DataHubGraph\n\ngms_endpoint = "http://localhost:8080"\nemitter = DatahubRestEmitter(gms_server=gms_endpoint, extra_headers={})\ngraph = DataHubGraph(DatahubClientConfig(server=gms_endpoint))\n\ndataset_urn = builder.make_dataset_urn(\n    platform="snowflake", name="analytics.public.orders", env="PROD"\n)\n\nfield_urn = builder.make_schema_field_urn(\n    parent_urn=dataset_urn, field_path="customer_id"\n)\n\ncurrent_terms = graph.get_aspect(\n    entity_urn=field_urn, aspect_type=models.GlossaryTermsClass\n)\n\nterm_to_add = builder.make_term_urn("CustomerIdentifier")\nterm_association = models.GlossaryTermAssociationClass(urn=term_to_add)\n\nif current_terms and current_terms.terms:\n    if term_to_add not in [term.urn for term in current_terms.terms]:\n        current_terms.terms.append(term_association)\nelse:\n    current_terms = models.GlossaryTermsClass(\n        terms=[term_association],\n        auditStamp=models.AuditStampClass(time=0, actor="urn:li:corpuser:datahub"),\n    )\n\nemitter.emit(\n    MetadataChangeProposalWrapper(\n        entityUrn=field_urn,\n        aspect=current_terms,\n    )\n)\n\n'))),(0,n.yg)("h3",{id:"business-attributes"},"Business Attributes"),(0,n.yg)("p",null,"The ",(0,n.yg)("inlineCode",{parentName:"p"},"businessAttributes")," aspect allows association of business attribute definitions with schema fields. Business attributes provide a way to attach enterprise-specific metadata dimensions (like data classification, retention policies, or business rules) directly to fields."),(0,n.yg)("p",null,"This is particularly useful for organizations that need to track custom governance metadata at the field level that isn't covered by standard aspects."),(0,n.yg)("h3",{id:"structured-properties"},"Structured Properties"),(0,n.yg)("p",null,"Schema fields support structured properties via the ",(0,n.yg)("inlineCode",{parentName:"p"},"structuredProperties")," aspect, allowing organizations to extend the metadata model with custom typed properties. This is useful for tracking field-level metadata like:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Data quality scores"),(0,n.yg)("li",{parentName:"ul"},"Business criticality ratings"),(0,n.yg)("li",{parentName:"ul"},"Custom classification schemes"),(0,n.yg)("li",{parentName:"ul"},"Regulatory compliance markers")),(0,n.yg)("details",null,(0,n.yg)("summary",null,"Python SDK: Add structured properties to a schema field"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-python"},'import time\n\nimport datahub.emitter.mce_builder as builder\nimport datahub.metadata.schema_classes as models\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.ingestion.graph.client import DatahubClientConfig, DataHubGraph\n\ngms_endpoint = "http://localhost:8080"\nemitter = DatahubRestEmitter(gms_server=gms_endpoint, extra_headers={})\ngraph = DataHubGraph(DatahubClientConfig(server=gms_endpoint))\n\ndataset_urn = builder.make_dataset_urn(\n    platform="hive", name="logging.events.clickstream", env="PROD"\n)\n\nfield_urn = builder.make_schema_field_urn(parent_urn=dataset_urn, field_path="user_id")\n\ncurrent_properties = graph.get_aspect(\n    entity_urn=field_urn, aspect_type=models.StructuredPropertiesClass\n)\n\nproperty_urn = "urn:li:structuredProperty:io.acryl.dataQuality.score"\nproperty_value = "0.95"\n\nnew_assignment = models.StructuredPropertyValueAssignmentClass(\n    propertyUrn=property_urn,\n    values=[property_value],\n    created=models.AuditStampClass(\n        time=int(time.time() * 1000), actor=builder.make_user_urn("datahub")\n    ),\n)\n\nif current_properties and current_properties.properties:\n    property_exists = False\n    for i, prop in enumerate(current_properties.properties):\n        if prop.propertyUrn == property_urn:\n            current_properties.properties[i] = new_assignment\n            property_exists = True\n            break\n    if not property_exists:\n        current_properties.properties.append(new_assignment)\nelse:\n    current_properties = models.StructuredPropertiesClass(properties=[new_assignment])\n\nemitter.emit(\n    MetadataChangeProposalWrapper(\n        entityUrn=field_urn,\n        aspect=current_properties,\n    )\n)\n\n'))),(0,n.yg)("h3",{id:"field-aliases-schemafieldaliases"},"Field Aliases (schemaFieldAliases)"),(0,n.yg)("p",null,"The ",(0,n.yg)("inlineCode",{parentName:"p"},"schemaFieldAliases")," aspect stores alternative URNs for a schema field. This is useful when:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Field paths change due to schema evolution"),(0,n.yg)("li",{parentName:"ul"},"Multiple field path formats are used (v1 vs v2)"),(0,n.yg)("li",{parentName:"ul"},"Cross-platform field references need to be maintained")),(0,n.yg)("h3",{id:"deprecation"},"Deprecation"),(0,n.yg)("p",null,"Fields can be marked as deprecated using the ",(0,n.yg)("inlineCode",{parentName:"p"},"deprecation")," aspect, indicating they should not be used in new applications or analyses. The deprecation aspect includes:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Deprecation timestamp"),(0,n.yg)("li",{parentName:"ul"},"Optional note explaining the deprecation"),(0,n.yg)("li",{parentName:"ul"},"Optional actor who deprecated the field")),(0,n.yg)("h3",{id:"logical-parent"},"Logical Parent"),(0,n.yg)("p",null,"The ",(0,n.yg)("inlineCode",{parentName:"p"},"logicalParent")," aspect can associate a schema field with a logical parent entity (like a container or domain), enabling organizational hierarchies that differ from the physical dataset structure."),(0,n.yg)("h3",{id:"forms"},"Forms"),(0,n.yg)("p",null,"Forms can be attached to schema fields via the ",(0,n.yg)("inlineCode",{parentName:"p"},"forms")," aspect, enabling structured data collection and validation at the field level. This is useful for capturing field-level certifications, approvals, or additional metadata."),(0,n.yg)("h3",{id:"status"},"Status"),(0,n.yg)("p",null,"The ",(0,n.yg)("inlineCode",{parentName:"p"},"status")," aspect indicates whether a schema field is active or has been soft-deleted."),(0,n.yg)("h3",{id:"test-results"},"Test Results"),(0,n.yg)("p",null,"The ",(0,n.yg)("inlineCode",{parentName:"p"},"testResults")," aspect can store results of data quality tests run on specific fields, linking test outcomes directly to the columns they validate."),(0,n.yg)("h3",{id:"subtypes"},"SubTypes"),(0,n.yg)("p",null,"The ",(0,n.yg)("inlineCode",{parentName:"p"},"subTypes")," aspect allows categorization of schema fields beyond their data type, enabling custom classification schemes."),(0,n.yg)("h2",{id:"code-examples"},"Code Examples"),(0,n.yg)("h3",{id:"querying-a-schema-field-via-rest-api"},"Querying a Schema Field via REST API"),(0,n.yg)("p",null,"The standard GET API can be used to retrieve schema field entities and their aspects:"),(0,n.yg)("details",null,(0,n.yg)("summary",null,"Fetch a schemaField entity"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-python"},'from typing import Any, cast\n\nimport datahub.emitter.mce_builder as builder\nfrom datahub.ingestion.graph.client import DatahubClientConfig, DataHubGraph\n\ngms_endpoint = "http://localhost:8080"\ngraph = DataHubGraph(DatahubClientConfig(server=gms_endpoint))\n\ndataset_urn = builder.make_dataset_urn(\n    platform="postgres", name="public.customers", env="PROD"\n)\n\nfield_urn = builder.make_schema_field_urn(\n    parent_urn=dataset_urn, field_path="email_address"\n)\n\nentity = graph.get_entity_semityped(entity_urn=field_urn)\n\nif entity:\n    print(f"Schema Field URN: {field_urn}")\n    print(f"Entity Type: {entity.get(\'entityType\')}")\n\n    aspects = cast(dict[str, Any], entity.get("aspects", {}))\n\n    if "globalTags" in aspects:\n        tags = aspects["globalTags"]["tags"]\n        print(f"Tags: {[tag[\'tag\'] for tag in tags]}")\n\n    if "glossaryTerms" in aspects:\n        terms = aspects["glossaryTerms"]["terms"]\n        print(f"Glossary Terms: {[term[\'urn\'] for term in terms]}")\n\n    if "documentation" in aspects:\n        docs = aspects["documentation"]["documentations"]\n        for doc in docs:\n            print(f"Documentation: {doc[\'documentation\'][:100]}...")\n\n    if "structuredProperties" in aspects:\n        props = aspects["structuredProperties"]["properties"]\n        for prop in props:\n            print(f"Property {prop[\'propertyUrn\']}: {prop[\'values\']}")\nelse:\n    print(f"Schema field {field_urn} not found")\n\n')),(0,n.yg)("p",null,"Example API call:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-bash"},"curl 'http://localhost:8080/entities/urn%3Ali%3AschemaField%3A(urn%3Ali%3Adataset%3A(urn%3Ali%3AdataPlatform%3Apostgres%2Cpublic.users%2CPROD)%2Cuser_id)'\n")),(0,n.yg)("p",null,"This returns all aspects associated with the schema field, including tags, terms, documentation, and structured properties.")),(0,n.yg)("h3",{id:"working-with-fine-grained-lineage"},"Working with Fine-Grained Lineage"),(0,n.yg)("p",null,"Schema fields are central to fine-grained (column-level) lineage. When defining lineage between datasets, you can specify which fields flow from upstream to downstream:"),(0,n.yg)("details",null,(0,n.yg)("summary",null,"Example lineage query showing field-level relationships"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-bash"},"# Find upstream fields of a specific schema field\ncurl 'http://localhost:8080/relationships?direction=OUTGOING&urn=urn%3Ali%3AschemaField%3A(urn%3Ali%3Adataset%3A(urn%3Ali%3AdataPlatform%3Apostgres%2Cpublic.orders%2CPROD)%2Cuser_id)&types=DownstreamOf'\n")),(0,n.yg)("p",null,"This shows which upstream fields contribute to this field's values, enabling impact analysis at the column level.")),(0,n.yg)("h2",{id:"integration-points"},"Integration Points"),(0,n.yg)("h3",{id:"relationship-with-datasets"},"Relationship with Datasets"),(0,n.yg)("p",null,"Schema fields have a parent-child relationship with datasets. The dataset's ",(0,n.yg)("inlineCode",{parentName:"p"},"schemaMetadata")," aspect defines the structure and metadata of fields, while individual schemaField entities allow direct metadata attachment at the field level."),(0,n.yg)("p",null,"Key integration points:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Fields are referenced in ",(0,n.yg)("inlineCode",{parentName:"li"},"schemaMetadata")," and ",(0,n.yg)("inlineCode",{parentName:"li"},"editableSchemaMetadata")," aspects of datasets"),(0,n.yg)("li",{parentName:"ul"},"Field-level tags and terms can be set via dataset aspects (",(0,n.yg)("inlineCode",{parentName:"li"},"schemaMetadata"),") or directly on schemaField entities"),(0,n.yg)("li",{parentName:"ul"},"The UI typically modifies ",(0,n.yg)("inlineCode",{parentName:"li"},"editableSchemaMetadata")," on the dataset, while ingestion connectors set ",(0,n.yg)("inlineCode",{parentName:"li"},"schemaMetadata"))),(0,n.yg)("h3",{id:"fine-grained-lineage"},"Fine-Grained Lineage"),(0,n.yg)("p",null,"Schema fields are essential for column-level lineage:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"DataJob entities"),": The ",(0,n.yg)("inlineCode",{parentName:"li"},"dataJobInputOutput")," aspect can specify ",(0,n.yg)("inlineCode",{parentName:"li"},"inputDatasetFields")," and ",(0,n.yg)("inlineCode",{parentName:"li"},"outputDatasetFields")),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Dataset lineage"),": The ",(0,n.yg)("inlineCode",{parentName:"li"},"upstreamLineage")," aspect on datasets can include ",(0,n.yg)("inlineCode",{parentName:"li"},"fineGrainedLineages")," that map specific fields"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Lineage queries"),": Field-level lineage appears as relationships between schemaField entities")),(0,n.yg)("h3",{id:"graphql-api"},"GraphQL API"),(0,n.yg)("p",null,"The GraphQL API exposes schema field entities as first-class entities with the ",(0,n.yg)("inlineCode",{parentName:"p"},"SchemaFieldEntity")," type. Key resolvers include:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Fetching field metadata (tags, terms, documentation)"),(0,n.yg)("li",{parentName:"ul"},"Querying field lineage relationships"),(0,n.yg)("li",{parentName:"ul"},"Searching for fields across datasets")),(0,n.yg)("p",null,"Note: Field fetching via GraphQL is controlled by the ",(0,n.yg)("inlineCode",{parentName:"p"},"schemaFieldEntityFetchEnabled")," feature flag. When disabled, schema field metadata is accessed only through the parent dataset's schema aspects."),(0,n.yg)("h3",{id:"search-and-discovery"},"Search and Discovery"),(0,n.yg)("p",null,"Schema fields are indexed for search, enabling users to:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Find datasets by column names"),(0,n.yg)("li",{parentName:"ul"},"Search for fields with specific tags or terms"),(0,n.yg)("li",{parentName:"ul"},"Discover fields by description content"),(0,n.yg)("li",{parentName:"ul"},"Filter by field-level classifications")),(0,n.yg)("h2",{id:"notable-exceptions"},"Notable Exceptions"),(0,n.yg)("h3",{id:"dual-access-patterns"},"Dual Access Patterns"),(0,n.yg)("p",null,"Schema field metadata can be accessed and modified in two ways:"),(0,n.yg)("ol",null,(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("strong",{parentName:"li"},"Via the parent dataset"),": Using ",(0,n.yg)("inlineCode",{parentName:"li"},"schemaMetadata")," or ",(0,n.yg)("inlineCode",{parentName:"li"},"editableSchemaMetadata")," aspects on the dataset"),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("strong",{parentName:"li"},"Directly on schemaField entities"),": Using aspects like ",(0,n.yg)("inlineCode",{parentName:"li"},"globalTags"),", ",(0,n.yg)("inlineCode",{parentName:"li"},"glossaryTerms"),", ",(0,n.yg)("inlineCode",{parentName:"li"},"documentation")," on the schemaField URN")),(0,n.yg)("p",null,"Best practices:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Ingestion connectors should use dataset-level aspects (",(0,n.yg)("inlineCode",{parentName:"li"},"schemaMetadata"),")"),(0,n.yg)("li",{parentName:"ul"},"UI edits typically use dataset-level aspects (",(0,n.yg)("inlineCode",{parentName:"li"},"editableSchemaMetadata"),")"),(0,n.yg)("li",{parentName:"ul"},"Direct schemaField entity updates are useful for programmatic bulk operations or when working with field-level lineage")),(0,n.yg)("h3",{id:"feature-flag-dependency"},"Feature Flag Dependency"),(0,n.yg)("p",null,"The ability to fetch schemaField entities via GraphQL depends on the ",(0,n.yg)("inlineCode",{parentName:"p"},"schemaFieldEntityFetchEnabled")," feature flag. When disabled:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Schema field entities are not directly queryable"),(0,n.yg)("li",{parentName:"ul"},"Field metadata must be accessed through parent datasets"),(0,n.yg)("li",{parentName:"ul"},"Field-level operations may have limited functionality")),(0,n.yg)("p",null,"This flag exists for performance reasons, as materializing individual field entities can be expensive for datasets with hundreds of columns."),(0,n.yg)("h3",{id:"field-path-encoding"},"Field Path Encoding"),(0,n.yg)("p",null,"Field paths in schemaField URNs must be URL-encoded if they contain special characters (spaces, special symbols, etc.). Always use the ",(0,n.yg)("inlineCode",{parentName:"p"},"make_schema_field_urn")," utility function from ",(0,n.yg)("inlineCode",{parentName:"p"},"datahub.emitter.mce_builder")," to construct URNs correctly:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-python"},'from datahub.emitter.mce_builder import make_schema_field_urn\n\n# Automatically handles encoding\nfield_urn = make_schema_field_urn(\n    parent_urn="urn:li:dataset:(urn:li:dataPlatform:snowflake,db.schema.table,PROD)",\n    field_path="first name"  # Will be encoded as "first%20name"\n)\n')),(0,n.yg)("h3",{id:"v1-vs-v2-field-paths"},"V1 vs V2 Field Paths"),(0,n.yg)("p",null,"DataHub supports two field path formats:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"V1"),": Simple dot notation (e.g., ",(0,n.yg)("inlineCode",{parentName:"li"},"address.zipcode"),")"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"V2"),": Type-aware notation (e.g., ",(0,n.yg)("inlineCode",{parentName:"li"},"[version=2.0].[type=struct].address.[type=string].zipcode"),")")),(0,n.yg)("p",null,"V2 field paths are required for:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Union types where field names alone are ambiguous"),(0,n.yg)("li",{parentName:"ul"},"Complex nested structures with type information"),(0,n.yg)("li",{parentName:"ul"},"Precise field path disambiguation")),(0,n.yg)("p",null,"Most simple schemas can use v1 field paths. Use v2 when dealing with complex types or when ingestion connectors generate them."),(0,n.yg)("h2",{id:"technical-reference"},"Technical Reference"),(0,n.yg)("p",null,"For technical details about fields, searchability, and relationships, view the ",(0,n.yg)("strong",{parentName:"p"},"Columns")," tab in DataHub."))}g.isMDXComponent=!0}}]);