"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[42822],{15680:(e,t,a)=>{a.d(t,{xA:()=>d,yg:()=>c});var n=a(96540);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=p(a),h=i,c=m["".concat(o,".").concat(h)]||m[h]||u[h]||r;return a?n.createElement(c,s(s({ref:t},d),{},{components:a})):n.createElement(c,s({ref:t},d))}));function c(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,s=new Array(r);s[0]=h;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[m]="string"==typeof e?e:i,s[1]=l;for(var p=2;p<r;p++)s[p]=a[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},47553:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>p,toc:()=>m});a(96540);var n=a(15680);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))})),e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}const l={sidebar_position:30,title:"ER Model Relationship",slug:"/generated/metamodel/entities/ermodelrelationship-datahub",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/erModelRelationship-datahub.md"},o="ER Model Relationship",p={unversionedId:"docs/generated/metamodel/entities/erModelRelationship-datahub",id:"docs/generated/metamodel/entities/erModelRelationship-datahub",title:"ER Model Relationship",description:"Entity-Relationship (ER) Model Relationships represent the connections between entities in an entity-relationship diagram, specifically modeling how dataset fields relate to each other through foreign key constraints, joins, and other referential relationships. In DataHub, these relationships capture the semantic connections between tables, enabling users to understand data structure, enforce referential integrity, and trace data lineage at the field level.",source:"@site/genDocs/docs/generated/metamodel/entities/erModelRelationship-datahub.md",sourceDirName:"docs/generated/metamodel/entities",slug:"/generated/metamodel/entities/ermodelrelationship-datahub",permalink:"/docs/generated/metamodel/entities/ermodelrelationship-datahub",draft:!1,editUrl:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/erModelRelationship-datahub.md",tags:[],version:"current",sidebarPosition:30,frontMatter:{sidebar_position:30,title:"ER Model Relationship",slug:"/generated/metamodel/entities/ermodelrelationship-datahub",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/erModelRelationship-datahub.md"},sidebar:"overviewSidebar",previous:{title:"DataHubView",permalink:"/docs/generated/metamodel/entities/datahubview"},next:{title:"ER Model Relationship",permalink:"/docs/generated/metamodel/entities/ermodelrelationship"}},d={},m=[{value:"Identity",id:"identity",level:2},{value:"Example URNs",id:"example-urns",level:3},{value:"ID Generation",id:"id-generation",level:3},{value:"Important Capabilities",id:"important-capabilities",level:2},{value:"Relationship Properties",id:"relationship-properties",level:3},{value:"Core Attributes",id:"core-attributes",level:4},{value:"Cardinality Types",id:"cardinality-types",level:4},{value:"Field Mappings",id:"field-mappings",level:4},{value:"Custom Properties",id:"custom-properties",level:4},{value:"Timestamps",id:"timestamps",level:4},{value:"Creating an ER Model Relationship",id:"creating-an-er-model-relationship",level:3},{value:"Editable Properties",id:"editable-properties",level:3},{value:"Updating Editable Properties",id:"updating-editable-properties",level:4},{value:"Tags and Glossary Terms",id:"tags-and-glossary-terms",level:3},{value:"Adding Tags",id:"adding-tags",level:4},{value:"Adding Glossary Terms",id:"adding-glossary-terms",level:4},{value:"Ownership",id:"ownership",level:3},{value:"Complex Relationships",id:"complex-relationships",level:3},{value:"Querying Relationships",id:"querying-relationships",level:3},{value:"Integration Points",id:"integration-points",level:2},{value:"Dataset Integration",id:"dataset-integration",level:3},{value:"Schema Field Integration",id:"schema-field-integration",level:3},{value:"Data Lineage",id:"data-lineage",level:3},{value:"GraphQL API",id:"graphql-api",level:3},{value:"Authorization",id:"authorization",level:3},{value:"Notable Exceptions",id:"notable-exceptions",level:2},{value:"Non-directional Relationships",id:"non-directional-relationships",level:3},{value:"Relationship Lifecycle",id:"relationship-lifecycle",level:3},{value:"Schema Evolution",id:"schema-evolution",level:3},{value:"Platform Support",id:"platform-support",level:3},{value:"Future Considerations",id:"future-considerations",level:3},{value:"Technical Reference",id:"technical-reference",level:2}],u={toc:m},h="wrapper";function c(e){var{components:t}=e,a=s(e,["components"]);return(0,n.yg)(h,r(function(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{},n=Object.keys(a);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(a).filter((function(e){return Object.getOwnPropertyDescriptor(a,e).enumerable})))),n.forEach((function(t){i(e,t,a[t])}))}return e}({},u,a),{components:t,mdxType:"MDXLayout"}),(0,n.yg)("h1",{id:"er-model-relationship"},"ER Model Relationship"),(0,n.yg)("p",null,"Entity-Relationship (ER) Model Relationships represent the connections between entities in an entity-relationship diagram, specifically modeling how dataset fields relate to each other through foreign key constraints, joins, and other referential relationships. In DataHub, these relationships capture the semantic connections between tables, enabling users to understand data structure, enforce referential integrity, and trace data lineage at the field level."),(0,n.yg)("p",null,"ER Model Relationships are particularly valuable for documenting database schemas, data warehouse models, and any structured data system where understanding table relationships is critical for data governance, impact analysis, and query optimization."),(0,n.yg)("h2",{id:"identity"},"Identity"),(0,n.yg)("p",null,"ER Model Relationships are uniquely identified by a single identifier:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"id"),": A unique string identifier for the relationship. When created programmatically, this is typically generated as an MD5 hash based on the relationship name and the two datasets involved (sorted alphabetically to ensure consistency).")),(0,n.yg)("p",null,"The URN structure follows the pattern:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre"},"urn:li:erModelRelationship:<id>\n")),(0,n.yg)("h3",{id:"example-urns"},"Example URNs"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre"},"urn:li:erModelRelationship:employee_to_company\nurn:li:erModelRelationship:a1b2c3d4e5f6g7h8i9j0\n")),(0,n.yg)("h3",{id:"id-generation"},"ID Generation"),(0,n.yg)("p",null,"When creating relationships through the UI or API, the ID is often generated deterministically using a hash function to ensure consistency:"),(0,n.yg)("ol",null,(0,n.yg)("li",{parentName:"ol"},"Create a JSON string with keys in alphabetical order: ",(0,n.yg)("inlineCode",{parentName:"li"},"Destination"),", ",(0,n.yg)("inlineCode",{parentName:"li"},"ERModelRelationName"),", ",(0,n.yg)("inlineCode",{parentName:"li"},"Source")),(0,n.yg)("li",{parentName:"ol"},'Use the lower lexicographic dataset URN as "Destination" and the higher as "Source"'),(0,n.yg)("li",{parentName:"ol"},"Generate an MD5 hash of this JSON string")),(0,n.yg)("p",null,"This ensures that the same relationship between two datasets always gets the same ID, regardless of creation order."),(0,n.yg)("h2",{id:"important-capabilities"},"Important Capabilities"),(0,n.yg)("h3",{id:"relationship-properties"},"Relationship Properties"),(0,n.yg)("p",null,"ER Model Relationships capture essential metadata about how datasets connect to each other through the ",(0,n.yg)("inlineCode",{parentName:"p"},"erModelRelationshipProperties")," aspect. This core aspect contains:"),(0,n.yg)("h4",{id:"core-attributes"},"Core Attributes"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"name"),': A human-readable name for the relationship (e.g., "Employee to Company Relationship")'),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"source"),": The URN of the source dataset (first entity in the relationship)"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"destination"),": The URN of the destination dataset (second entity in the relationship)"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"cardinality"),": Defines the relationship type between datasets")),(0,n.yg)("h4",{id:"cardinality-types"},"Cardinality Types"),(0,n.yg)("p",null,"DataHub supports four cardinality types that describe how records in one dataset relate to records in another:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("p",{parentName:"li"},(0,n.yg)("strong",{parentName:"p"},"ONE_ONE"),": One-to-one relationship. Each record in the source dataset corresponds to exactly one record in the destination dataset."),(0,n.yg)("ul",{parentName:"li"},(0,n.yg)("li",{parentName:"ul"},"Example: Employee \u2192 EmployeeDetails (one employee has one detail record)"))),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("p",{parentName:"li"},(0,n.yg)("strong",{parentName:"p"},"ONE_N"),": One-to-many relationship. Each record in the source dataset can correspond to multiple records in the destination dataset."),(0,n.yg)("ul",{parentName:"li"},(0,n.yg)("li",{parentName:"ul"},"Example: Department \u2192 Employee (one department has many employees)"))),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("p",{parentName:"li"},(0,n.yg)("strong",{parentName:"p"},"N_ONE"),": Many-to-one relationship. Multiple records in the source dataset can correspond to one record in the destination dataset."),(0,n.yg)("ul",{parentName:"li"},(0,n.yg)("li",{parentName:"ul"},"Example: Employee \u2192 Company (many employees belong to one company)"))),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("p",{parentName:"li"},(0,n.yg)("strong",{parentName:"p"},"N_N"),": Many-to-many relationship. Records in both datasets can have multiple corresponding records in the other dataset."),(0,n.yg)("ul",{parentName:"li"},(0,n.yg)("li",{parentName:"ul"},"Example: Student \u2192 Course (students take many courses, courses have many students)")))),(0,n.yg)("h4",{id:"field-mappings"},"Field Mappings"),(0,n.yg)("p",null,"The ",(0,n.yg)("inlineCode",{parentName:"p"},"relationshipFieldMappings")," array defines which specific fields connect the two datasets. Each mapping contains:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"sourceField"),': The field path in the source dataset (e.g., "company_id")'),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"destinationField"),': The field path in the destination dataset (e.g., "id")')),(0,n.yg)("p",null,"Multiple field mappings can be specified for composite keys where the relationship depends on multiple fields."),(0,n.yg)("h4",{id:"custom-properties"},"Custom Properties"),(0,n.yg)("p",null,"Like other DataHub entities, ER Model Relationships support custom properties for storing additional metadata such as:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},'Constraint types (e.g., "Foreign Key", "Referential Integrity")'),(0,n.yg)("li",{parentName:"ul"},"Index information"),(0,n.yg)("li",{parentName:"ul"},"Database-specific metadata"),(0,n.yg)("li",{parentName:"ul"},"Business rules or validation logic")),(0,n.yg)("h4",{id:"timestamps"},"Timestamps"),(0,n.yg)("p",null,"Relationships include optional timestamp information to track when they were created and last modified in the source system:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"created"),": AuditStamp with creation time and actor"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"lastModified"),": AuditStamp with last modification time and actor")),(0,n.yg)("h3",{id:"creating-an-er-model-relationship"},"Creating an ER Model Relationship"),(0,n.yg)("p",null,"Here's a complete example showing how to create two datasets and establish a many-to-one relationship between them:"),(0,n.yg)("details",null,(0,n.yg)("summary",null,"Python SDK: Create an ER Model Relationship"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-python"},'# metadata-ingestion/examples/library/ermodelrelationship_create_basic.py\nimport os\nimport time\n\nfrom datahub.emitter.mce_builder import make_data_platform_urn, make_dataset_urn\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.schema_classes import (\n    AuditStampClass,\n    ERModelRelationshipCardinalityClass,\n    ERModelRelationshipKeyClass,\n    ERModelRelationshipPropertiesClass,\n    NumberTypeClass,\n    OtherSchemaClass,\n    RelationshipFieldMappingClass,\n    SchemaFieldClass,\n    SchemaFieldDataTypeClass,\n    SchemaMetadataClass,\n    StringTypeClass,\n)\n\nGMS_ENDPOINT = os.getenv("DATAHUB_GMS_URL", "http://localhost:8080")\nGMS_TOKEN = os.getenv("DATAHUB_GMS_TOKEN")\nPLATFORM = "mysql"\nENV = "PROD"\n\nemitter = DatahubRestEmitter(gms_server=GMS_ENDPOINT, token=GMS_TOKEN)\n\n\ndef create_dataset_with_schema(\n    dataset_name: str, fields: list[SchemaFieldClass]\n) -> str:\n    """Helper function to create a dataset with schema."""\n    dataset_urn = make_dataset_urn(PLATFORM, dataset_name, ENV)\n\n    schema_metadata = SchemaMetadataClass(\n        schemaName=dataset_name,\n        platform=make_data_platform_urn(PLATFORM),\n        fields=fields,\n        version=0,\n        hash="",\n        platformSchema=OtherSchemaClass(rawSchema=""),\n    )\n\n    emitter.emit_mcp(\n        MetadataChangeProposalWrapper(\n            entityUrn=dataset_urn,\n            aspect=schema_metadata,\n        )\n    )\n\n    return dataset_urn\n\n\ndef create_schema_field(\n    field_path: str, native_type: str, data_type: SchemaFieldDataTypeClass\n) -> SchemaFieldClass:\n    """Helper function to create a schema field."""\n    return SchemaFieldClass(\n        fieldPath=field_path,\n        type=data_type,\n        nativeDataType=native_type,\n        description=f"Field: {field_path}",\n        lastModified=AuditStampClass(\n            time=int(time.time() * 1000),\n            actor="urn:li:corpuser:datahub",\n        ),\n    )\n\n\n# Create Employee table\nemployee_fields = [\n    create_schema_field("id", "int", SchemaFieldDataTypeClass(type=NumberTypeClass())),\n    create_schema_field(\n        "name", "varchar(100)", SchemaFieldDataTypeClass(type=StringTypeClass())\n    ),\n    create_schema_field(\n        "email", "varchar(255)", SchemaFieldDataTypeClass(type=StringTypeClass())\n    ),\n    create_schema_field(\n        "company_id", "int", SchemaFieldDataTypeClass(type=NumberTypeClass())\n    ),\n]\nemployee_urn = create_dataset_with_schema("Employee", employee_fields)\nprint(f"Created Employee dataset: {employee_urn}")\n\n# Create Company table\ncompany_fields = [\n    create_schema_field("id", "int", SchemaFieldDataTypeClass(type=NumberTypeClass())),\n    create_schema_field(\n        "name", "varchar(200)", SchemaFieldDataTypeClass(type=StringTypeClass())\n    ),\n    create_schema_field(\n        "industry", "varchar(100)", SchemaFieldDataTypeClass(type=StringTypeClass())\n    ),\n]\ncompany_urn = create_dataset_with_schema("Company", company_fields)\nprint(f"Created Company dataset: {company_urn}")\n\n# Create ER Model Relationship\nrelationship_id = "employee_to_company"\nrelationship_urn = f"urn:li:erModelRelationship:{relationship_id}"\n\n# Emit the key aspect\nrelationship_key = ERModelRelationshipKeyClass(id=relationship_id)\nemitter.emit_mcp(\n    MetadataChangeProposalWrapper(\n        entityUrn=relationship_urn,\n        aspect=relationship_key,\n    )\n)\n\n# Emit the properties aspect\nrelationship_properties = ERModelRelationshipPropertiesClass(\n    name="Employee to Company Relationship",\n    source=employee_urn,\n    destination=company_urn,\n    relationshipFieldMappings=[\n        RelationshipFieldMappingClass(\n            sourceField="company_id",\n            destinationField="id",\n        )\n    ],\n    cardinality=ERModelRelationshipCardinalityClass.N_ONE,\n    customProperties={\n        "constraint_type": "FOREIGN_KEY",\n        "on_delete": "CASCADE",\n        "on_update": "CASCADE",\n    },\n    created=AuditStampClass(\n        time=int(time.time() * 1000),\n        actor="urn:li:corpuser:datahub",\n    ),\n)\n\nemitter.emit_mcp(\n    MetadataChangeProposalWrapper(\n        entityUrn=relationship_urn,\n        aspect=relationship_properties,\n    )\n)\n\nprint(f"Created ER Model Relationship: {relationship_urn}")\nprint(\n    "This N:1 relationship connects Employee.company_id to Company.id, "\n    "representing that many employees belong to one company."\n)\n\n'))),(0,n.yg)("h3",{id:"editable-properties"},"Editable Properties"),(0,n.yg)("p",null,"The ",(0,n.yg)("inlineCode",{parentName:"p"},"editableERModelRelationshipProperties")," aspect allows users to add or modify relationship metadata through the DataHub UI without overwriting information ingested from source systems. This separation follows the same pattern used across DataHub entities."),(0,n.yg)("p",null,"Editable properties include:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"description"),": Documentation explaining the relationship's purpose, constraints, or business logic"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"name"),": An alternative display name that overrides the source system name")),(0,n.yg)("h4",{id:"updating-editable-properties"},"Updating Editable Properties"),(0,n.yg)("details",null,(0,n.yg)("summary",null,"Python SDK: Update editable relationship properties"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-python"},'# metadata-ingestion/examples/library/ermodelrelationship_update_properties.py\nimport time\n\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.schema_classes import (\n    AuditStampClass,\n    EditableERModelRelationshipPropertiesClass,\n)\n\nGMS_ENDPOINT = "http://localhost:8080"\nrelationship_urn = "urn:li:erModelRelationship:employee_to_company"\n\nemitter = DatahubRestEmitter(gms_server=GMS_ENDPOINT, extra_headers={})\n\n# Create or update editable properties\naudit_stamp = AuditStampClass(\n    time=int(time.time() * 1000), actor="urn:li:corpuser:datahub"\n)\n\neditable_properties = EditableERModelRelationshipPropertiesClass(\n    name="Employee-Company Foreign Key",\n    description=(\n        "This relationship establishes referential integrity between the Employee "\n        "and Company tables. Each employee record must reference a valid company. "\n        "The relationship enforces CASCADE on both UPDATE and DELETE operations, "\n        "meaning changes to company IDs will propagate to employee records, and "\n        "deleting a company will delete all associated employees."\n    ),\n    created=audit_stamp,\n)\n\nemitter.emit_mcp(\n    MetadataChangeProposalWrapper(\n        entityUrn=relationship_urn,\n        aspect=editable_properties,\n    )\n)\n\nprint(f"Updated editable properties for ER Model Relationship {relationship_urn}")\nprint(f"Name: {editable_properties.name}")\nprint(f"Description: {editable_properties.description}")\n\n'))),(0,n.yg)("h3",{id:"tags-and-glossary-terms"},"Tags and Glossary Terms"),(0,n.yg)("p",null,"ER Model Relationships support tagging and glossary term attachment just like other DataHub entities. This allows you to categorize relationships, mark them with data classification tags, or link them to business concepts."),(0,n.yg)("h4",{id:"adding-tags"},"Adding Tags"),(0,n.yg)("p",null,"Tags can be used to classify relationships by type, importance, or data domain:"),(0,n.yg)("details",null,(0,n.yg)("summary",null,"Python SDK: Add a tag to an ER Model Relationship"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-python"},'# metadata-ingestion/examples/library/ermodelrelationship_add_tag.py\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.schema_classes import (\n    GlobalTagsClass,\n    TagAssociationClass,\n)\n\nGMS_ENDPOINT = "http://localhost:8080"\nrelationship_urn = "urn:li:erModelRelationship:employee_to_company"\ntag_urn = "urn:li:tag:ForeignKey"\n\nemitter = DatahubRestEmitter(gms_server=GMS_ENDPOINT, extra_headers={})\n\n# Read current tags\n# FIXME: emitter.get not available\n# gms_response = emitter.get(relationship_urn, aspects=["globalTags"])\ncurrent_tags: dict[\n    str, object\n] = {}  # gms_response.get("globalTags", {}) if gms_response else {}\n\n# Build new tags list\nexisting_tags = []\nif isinstance(current_tags, dict) and "tags" in current_tags:\n    tags_list = current_tags["tags"]\n    if isinstance(tags_list, list):\n        existing_tags = [tag["tag"] for tag in tags_list]\n\n# Add new tag if not already present\nif tag_urn not in existing_tags:\n    tag_associations = [\n        TagAssociationClass(tag=existing_tag) for existing_tag in existing_tags\n    ]\n    tag_associations.append(TagAssociationClass(tag=tag_urn))\n\n    global_tags = GlobalTagsClass(tags=tag_associations)\n\n    emitter.emit_mcp(\n        MetadataChangeProposalWrapper(\n            entityUrn=relationship_urn,\n            aspect=global_tags,\n        )\n    )\n\n    print(f"Added tag {tag_urn} to ER Model Relationship {relationship_urn}")\nelse:\n    print(f"Tag {tag_urn} already exists on {relationship_urn}")\n\n'))),(0,n.yg)("h4",{id:"adding-glossary-terms"},"Adding Glossary Terms"),(0,n.yg)("p",null,"Glossary terms connect relationships to business concepts and terminology:"),(0,n.yg)("details",null,(0,n.yg)("summary",null,"Python SDK: Add a glossary term to an ER Model Relationship"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-python"},'# metadata-ingestion/examples/library/ermodelrelationship_add_term.py\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.schema_classes import (\n    AuditStampClass,\n    GlossaryTermAssociationClass,\n    GlossaryTermsClass,\n)\n\nGMS_ENDPOINT = "http://localhost:8080"\nrelationship_urn = "urn:li:erModelRelationship:employee_to_company"\nterm_urn = "urn:li:glossaryTerm:ReferentialIntegrity"\n\nemitter = DatahubRestEmitter(gms_server=GMS_ENDPOINT, extra_headers={})\n\n# Read current glossary terms\n# FIXME: emitter.get not available\n# gms_response = emitter.get(relationship_urn, aspects=["glossaryTerms"])\ncurrent_terms: dict[\n    str, object\n] = {}  # gms_response.get("glossaryTerms", {}) if gms_response else {}\n\n# Build new terms list\nexisting_terms = []\nif isinstance(current_terms, dict) and "terms" in current_terms:\n    terms_list = current_terms["terms"]\n    if isinstance(terms_list, list):\n        existing_terms = [term["urn"] for term in terms_list]\n\n# Add new term if not already present\nif term_urn not in existing_terms:\n    term_associations = [\n        GlossaryTermAssociationClass(urn=existing_term)\n        for existing_term in existing_terms\n    ]\n    term_associations.append(GlossaryTermAssociationClass(urn=term_urn))\n\n    glossary_terms = GlossaryTermsClass(\n        terms=term_associations,\n        auditStamp=AuditStampClass(time=0, actor="urn:li:corpuser:datahub"),\n    )\n\n    emitter.emit_mcp(\n        MetadataChangeProposalWrapper(\n            entityUrn=relationship_urn,\n            aspect=glossary_terms,\n        )\n    )\n\n    print(f"Added glossary term {term_urn} to ER Model Relationship {relationship_urn}")\nelse:\n    print(f"Glossary term {term_urn} already exists on {relationship_urn}")\n\n'))),(0,n.yg)("h3",{id:"ownership"},"Ownership"),(0,n.yg)("p",null,"Ownership can be assigned to ER Model Relationships to indicate who is responsible for maintaining the relationship definition or who should be consulted about changes to the connected datasets."),(0,n.yg)("details",null,(0,n.yg)("summary",null,"Python SDK: Add an owner to an ER Model Relationship"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-python"},'# metadata-ingestion/examples/library/ermodelrelationship_add_owner.py\nimport time\n\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.schema_classes import (\n    AuditStampClass,\n    OwnerClass,\n    OwnershipClass,\n    OwnershipTypeClass,\n)\n\nGMS_ENDPOINT = "http://localhost:8080"\nrelationship_urn = "urn:li:erModelRelationship:employee_to_company"\nowner_urn = "urn:li:corpuser:jdoe"\n\nemitter = DatahubRestEmitter(gms_server=GMS_ENDPOINT, extra_headers={})\n\n# Read current ownership\n# FIXME: emitter.get not available\n# gms_response = emitter.get(relationship_urn, aspects=["ownership"])\ncurrent_ownership: dict[\n    str, object\n] = {}  # gms_response.get("ownership", {}) if gms_response else {}\n\n# Build new owners list\nexisting_owners = []\nif isinstance(current_ownership, dict) and "owners" in current_ownership:\n    owners_list = current_ownership["owners"]\n    if isinstance(owners_list, list):\n        existing_owners = [owner["owner"] for owner in owners_list]\n\n# Add new owner if not already present\nif owner_urn not in existing_owners:\n    owner_list = [\n        OwnerClass(owner=existing_owner, type=OwnershipTypeClass.DATAOWNER)\n        for existing_owner in existing_owners\n    ]\n    owner_list.append(\n        OwnerClass(\n            owner=owner_urn,\n            type=OwnershipTypeClass.DATAOWNER,\n        )\n    )\n\n    ownership = OwnershipClass(\n        owners=owner_list,\n        lastModified=AuditStampClass(\n            time=int(time.time() * 1000),\n            actor="urn:li:corpuser:datahub",\n        ),\n    )\n\n    emitter.emit_mcp(\n        MetadataChangeProposalWrapper(\n            entityUrn=relationship_urn,\n            aspect=ownership,\n        )\n    )\n\n    print(f"Added owner {owner_urn} to ER Model Relationship {relationship_urn}")\nelse:\n    print(f"Owner {owner_urn} already exists on {relationship_urn}")\n\n'))),(0,n.yg)("h3",{id:"complex-relationships"},"Complex Relationships"),(0,n.yg)("p",null,"ER Model Relationships can model sophisticated data structures including composite keys and many-to-many relationships through junction tables:"),(0,n.yg)("details",null,(0,n.yg)("summary",null,"Python SDK: Create a many-to-many relationship with composite keys"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-python"},'# metadata-ingestion/examples/library/ermodelrelationship_complex_many_to_many.py\nimport time\n\nfrom datahub.emitter.mce_builder import make_data_platform_urn, make_dataset_urn\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.schema_classes import (\n    AuditStampClass,\n    ERModelRelationshipCardinalityClass,\n    ERModelRelationshipKeyClass,\n    ERModelRelationshipPropertiesClass,\n    NumberTypeClass,\n    OtherSchemaClass,\n    RelationshipFieldMappingClass,\n    SchemaFieldClass,\n    SchemaFieldDataTypeClass,\n    SchemaMetadataClass,\n    StringTypeClass,\n)\n\nGMS_ENDPOINT = "http://localhost:8080"\nPLATFORM = "postgres"\nENV = "PROD"\n\nemitter = DatahubRestEmitter(gms_server=GMS_ENDPOINT, extra_headers={})\n\n\ndef create_dataset_with_schema(\n    dataset_name: str, fields: list[SchemaFieldClass]\n) -> str:\n    """Helper function to create a dataset with schema."""\n    dataset_urn = make_dataset_urn(PLATFORM, dataset_name, ENV)\n\n    schema_metadata = SchemaMetadataClass(\n        schemaName=dataset_name,\n        platform=make_data_platform_urn(PLATFORM),\n        fields=fields,\n        version=0,\n        hash="",\n        platformSchema=OtherSchemaClass(rawSchema=""),\n    )\n\n    emitter.emit_mcp(\n        MetadataChangeProposalWrapper(\n            entityUrn=dataset_urn,\n            aspect=schema_metadata,\n        )\n    )\n\n    return dataset_urn\n\n\ndef create_schema_field(\n    field_path: str, native_type: str, data_type: SchemaFieldDataTypeClass\n) -> SchemaFieldClass:\n    """Helper function to create a schema field."""\n    return SchemaFieldClass(\n        fieldPath=field_path,\n        type=data_type,\n        nativeDataType=native_type,\n        description=f"Field: {field_path}",\n        lastModified=AuditStampClass(\n            time=int(time.time() * 1000),\n            actor="urn:li:corpuser:datahub",\n        ),\n    )\n\n\n# Create Student table\nstudent_fields = [\n    create_schema_field("id", "int", SchemaFieldDataTypeClass(type=NumberTypeClass())),\n    create_schema_field(\n        "name", "varchar(100)", SchemaFieldDataTypeClass(type=StringTypeClass())\n    ),\n    create_schema_field(\n        "email", "varchar(255)", SchemaFieldDataTypeClass(type=StringTypeClass())\n    ),\n]\nstudent_urn = create_dataset_with_schema("Student", student_fields)\nprint(f"Created Student dataset: {student_urn}")\n\n# Create Course table\ncourse_fields = [\n    create_schema_field("id", "int", SchemaFieldDataTypeClass(type=NumberTypeClass())),\n    create_schema_field(\n        "code", "varchar(20)", SchemaFieldDataTypeClass(type=StringTypeClass())\n    ),\n    create_schema_field(\n        "title", "varchar(200)", SchemaFieldDataTypeClass(type=StringTypeClass())\n    ),\n]\ncourse_urn = create_dataset_with_schema("Course", course_fields)\nprint(f"Created Course dataset: {course_urn}")\n\n# Create StudentCourse junction table with composite key\nstudent_course_fields = [\n    create_schema_field(\n        "student_id", "int", SchemaFieldDataTypeClass(type=NumberTypeClass())\n    ),\n    create_schema_field(\n        "course_id", "int", SchemaFieldDataTypeClass(type=NumberTypeClass())\n    ),\n    create_schema_field(\n        "enrollment_date", "date", SchemaFieldDataTypeClass(type=StringTypeClass())\n    ),\n    create_schema_field(\n        "grade", "varchar(2)", SchemaFieldDataTypeClass(type=StringTypeClass())\n    ),\n]\nstudent_course_urn = create_dataset_with_schema("StudentCourse", student_course_fields)\nprint(f"Created StudentCourse junction table: {student_course_urn}")\n\n# Create relationship: StudentCourse -> Student (many-to-one)\nstudent_relationship_id = "student_course_to_student"\nstudent_relationship_urn = f"urn:li:erModelRelationship:{student_relationship_id}"\n\nstudent_relationship_key = ERModelRelationshipKeyClass(id=student_relationship_id)\nemitter.emit_mcp(\n    MetadataChangeProposalWrapper(\n        entityUrn=student_relationship_urn,\n        aspect=student_relationship_key,\n    )\n)\n\nstudent_relationship_properties = ERModelRelationshipPropertiesClass(\n    name="StudentCourse to Student Relationship",\n    source=student_course_urn,\n    destination=student_urn,\n    relationshipFieldMappings=[\n        RelationshipFieldMappingClass(\n            sourceField="student_id",\n            destinationField="id",\n        )\n    ],\n    cardinality=ERModelRelationshipCardinalityClass.N_ONE,\n    customProperties={\n        "constraint_type": "FOREIGN_KEY",\n        "part_of_composite_key": "true",\n    },\n    created=AuditStampClass(\n        time=int(time.time() * 1000),\n        actor="urn:li:corpuser:datahub",\n    ),\n)\n\nemitter.emit_mcp(\n    MetadataChangeProposalWrapper(\n        entityUrn=student_relationship_urn,\n        aspect=student_relationship_properties,\n    )\n)\n\nprint(f"Created relationship: {student_relationship_urn}")\n\n# Create relationship: StudentCourse -> Course (many-to-one)\ncourse_relationship_id = "student_course_to_course"\ncourse_relationship_urn = f"urn:li:erModelRelationship:{course_relationship_id}"\n\ncourse_relationship_key = ERModelRelationshipKeyClass(id=course_relationship_id)\nemitter.emit_mcp(\n    MetadataChangeProposalWrapper(\n        entityUrn=course_relationship_urn,\n        aspect=course_relationship_key,\n    )\n)\n\ncourse_relationship_properties = ERModelRelationshipPropertiesClass(\n    name="StudentCourse to Course Relationship",\n    source=student_course_urn,\n    destination=course_urn,\n    relationshipFieldMappings=[\n        RelationshipFieldMappingClass(\n            sourceField="course_id",\n            destinationField="id",\n        )\n    ],\n    cardinality=ERModelRelationshipCardinalityClass.N_ONE,\n    customProperties={\n        "constraint_type": "FOREIGN_KEY",\n        "part_of_composite_key": "true",\n    },\n    created=AuditStampClass(\n        time=int(time.time() * 1000),\n        actor="urn:li:corpuser:datahub",\n    ),\n)\n\nemitter.emit_mcp(\n    MetadataChangeProposalWrapper(\n        entityUrn=course_relationship_urn,\n        aspect=course_relationship_properties,\n    )\n)\n\nprint(f"Created relationship: {course_relationship_urn}")\n\nprint("\\nMany-to-many relationship established through junction table:")\nprint("- Student N:N Course (via StudentCourse junction table)")\nprint("- StudentCourse has composite primary key (student_id, course_id)")\nprint("- Each component of the composite key is a foreign key to its respective table")\n\n'))),(0,n.yg)("h3",{id:"querying-relationships"},"Querying Relationships"),(0,n.yg)("p",null,"ER Model Relationships can be queried using the standard DataHub REST API:"),(0,n.yg)("details",null,(0,n.yg)("summary",null,"Fetch an ER Model Relationship"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-bash"},"curl 'http://localhost:8080/entities/urn%3Ali%3AerModelRelationship%3Aemployee_to_company'\n")),(0,n.yg)("p",null,"The response includes all aspects of the relationship:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-json"},'{\n  "urn": "urn:li:erModelRelationship:employee_to_company",\n  "aspects": {\n    "erModelRelationshipKey": {\n      "id": "employee_to_company"\n    },\n    "erModelRelationshipProperties": {\n      "name": "Employee to Company Relationship",\n      "source": "urn:li:dataset:(urn:li:dataPlatform:mysql,Employee,PROD)",\n      "destination": "urn:li:dataset:(urn:li:dataPlatform:mysql,Company,PROD)",\n      "relationshipFieldMappings": [\n        {\n          "sourceField": "company_id",\n          "destinationField": "id"\n        }\n      ],\n      "cardinality": "N_ONE",\n      "customProperties": {\n        "constraint": "Foreign Key"\n      }\n    }\n  }\n}\n'))),(0,n.yg)("details",null,(0,n.yg)("summary",null,"Find all relationships for a dataset"),(0,n.yg)("p",null,"You can discover relationships connected to a specific dataset by querying the relationships API:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-bash"},"# Find relationships where the dataset is the source\ncurl 'http://localhost:8080/relationships?direction=OUTGOING&urn=urn%3Ali%3Adataset%3A(urn%3Ali%3AdataPlatform%3Amysql,Employee,PROD)&types=ermodelrelationA'\n\n# Find relationships where the dataset is the destination\ncurl 'http://localhost:8080/relationships?direction=INCOMING&urn=urn%3Ali%3Adataset%3A(urn%3Ali%3AdataPlatform%3Amysql,Company,PROD)&types=ermodelrelationB'\n"))),(0,n.yg)("h2",{id:"integration-points"},"Integration Points"),(0,n.yg)("p",null,"ER Model Relationships integrate with several other DataHub entities and features:"),(0,n.yg)("h3",{id:"dataset-integration"},"Dataset Integration"),(0,n.yg)("p",null,"ER Model Relationships are fundamentally connected to ",(0,n.yg)("a",{parentName:"p",href:"/docs/generated/metamodel/entities/dataset"},"Dataset")," entities. Each relationship must reference exactly two datasets:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Relationships are discoverable from dataset pages in the UI"),(0,n.yg)("li",{parentName:"ul"},"The GraphQL API automatically resolves source and destination dataset details"),(0,n.yg)("li",{parentName:"ul"},"Relationship information enriches dataset schema views")),(0,n.yg)("h3",{id:"schema-field-integration"},"Schema Field Integration"),(0,n.yg)("p",null,"While the entity stores field paths as strings, these correspond to ",(0,n.yg)("a",{parentName:"p",href:"/docs/generated/metamodel/entities/schemafield"},"SchemaField")," entities within the referenced datasets. This enables:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Visual representation of foreign key relationships in the UI"),(0,n.yg)("li",{parentName:"ul"},"Field-level lineage analysis"),(0,n.yg)("li",{parentName:"ul"},"Impact analysis when schema changes occur")),(0,n.yg)("h3",{id:"data-lineage"},"Data Lineage"),(0,n.yg)("p",null,"ER Model Relationships complement but are distinct from DataHub's lineage features:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"ER Model Relationships"),": Model the static structure and referential constraints between datasets"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Upstream/Downstream Lineage"),": Captures how data flows through transformations and pipelines")),(0,n.yg)("p",null,"Together, these features provide a complete picture of both data structure and data flow."),(0,n.yg)("h3",{id:"graphql-api"},"GraphQL API"),(0,n.yg)("p",null,"The DataHub GraphQL API provides rich querying capabilities for ER Model Relationships:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("inlineCode",{parentName:"li"},"erModelRelationship(urn: String!)"),": Fetch a specific relationship"),(0,n.yg)("li",{parentName:"ul"},"Create and update relationships through mutations"),(0,n.yg)("li",{parentName:"ul"},"Traverse from datasets to their relationships"),(0,n.yg)("li",{parentName:"ul"},"Bulk query capabilities for building ER diagrams")),(0,n.yg)("h3",{id:"authorization"},"Authorization"),(0,n.yg)("p",null,"Creating and modifying ER Model Relationships requires appropriate permissions in DataHub's policy framework. Users must have edit permissions on both the source and destination datasets to create a relationship between them."),(0,n.yg)("h2",{id:"notable-exceptions"},"Notable Exceptions"),(0,n.yg)("h3",{id:"non-directional-relationships"},"Non-directional Relationships"),(0,n.yg)("p",null,'While ER Model Relationships have "source" and "destination" fields, these do not necessarily imply directionality in the traditional sense of foreign keys:'),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"The source/destination ordering is primarily for internal consistency"),(0,n.yg)("li",{parentName:"ul"},"When generating IDs, datasets are ordered alphabetically to ensure the same relationship always produces the same ID"),(0,n.yg)("li",{parentName:"ul"},"Cardinality types (ONE_N vs N_ONE) explicitly capture the actual relationship direction")),(0,n.yg)("h3",{id:"relationship-lifecycle"},"Relationship Lifecycle"),(0,n.yg)("p",null,"ER Model Relationships are currently separate from the datasets they connect:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Deleting a dataset does not automatically delete its relationships"),(0,n.yg)("li",{parentName:"ul"},"Orphaned relationships (pointing to non-existent datasets) may exist after dataset deletion"),(0,n.yg)("li",{parentName:"ul"},"Applications should handle cases where relationship endpoints may not exist")),(0,n.yg)("h3",{id:"schema-evolution"},"Schema Evolution"),(0,n.yg)("p",null,"ER Model Relationships reference field paths as strings, not versioned schema references:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"If field names change in a dataset schema, the relationship may reference outdated field names"),(0,n.yg)("li",{parentName:"ul"},"No automatic validation ensures that referenced fields exist in current schemas"),(0,n.yg)("li",{parentName:"ul"},"Applications should implement field validation when creating relationships")),(0,n.yg)("h3",{id:"platform-support"},"Platform Support"),(0,n.yg)("p",null,"Not all data platforms have first-class support for ER Model Relationships:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Relational databases (MySQL, PostgreSQL, Oracle) naturally map to this model"),(0,n.yg)("li",{parentName:"ul"},"NoSQL databases and data lakes may not have explicit relationship metadata"),(0,n.yg)("li",{parentName:"ul"},"Some ingestion connectors automatically extract foreign key relationships, others do not")),(0,n.yg)("h3",{id:"future-considerations"},"Future Considerations"),(0,n.yg)("p",null,"The ER Model Relationship entity may evolve to include:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Additional relationship types beyond cardinality (inheritance, composition)"),(0,n.yg)("li",{parentName:"ul"},"Versioning to track relationship changes over time"),(0,n.yg)("li",{parentName:"ul"},"Bidirectional field mappings for complex transformation logic"),(0,n.yg)("li",{parentName:"ul"},"Integration with data quality rules and constraint validation")),(0,n.yg)("h2",{id:"technical-reference"},"Technical Reference"),(0,n.yg)("p",null,"For technical details about fields, searchability, and relationships, view the ",(0,n.yg)("strong",{parentName:"p"},"Columns")," tab in DataHub."))}c.isMDXComponent=!0}}]);