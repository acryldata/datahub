"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[40321],{15680:(e,t,a)=>{a.d(t,{xA:()=>p,yg:()=>g});var r=a(96540);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var o=r.createContext({}),y=function(e){var t=r.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=y(e.components);return r.createElement(o.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,o=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=y(a),d=n,g=m["".concat(o,".").concat(d)]||m[d]||u[d]||i;return a?r.createElement(g,s(s({ref:t},p),{},{components:a})):r.createElement(g,s({ref:t},p))}));function g(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,s=new Array(i);s[0]=d;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[m]="string"==typeof e?e:n,s[1]=l;for(var y=2;y<i;y++)s[y]=a[y];return r.createElement.apply(null,s)}return r.createElement.apply(null,a)}d.displayName="MDXCreateElement"},57051:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>g,frontMatter:()=>l,metadata:()=>y,toc:()=>m});a(96540);var r=a(15680);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))})),e}function s(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}const l={sidebar_position:22,title:"MLPrimaryKey",slug:"/generated/metamodel/entities/mlprimarykey-datahub",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/mlPrimaryKey-datahub.md"},o="MLPrimaryKey",y={unversionedId:"docs/generated/metamodel/entities/mlPrimaryKey-datahub",id:"docs/generated/metamodel/entities/mlPrimaryKey-datahub",title:"MLPrimaryKey",description:"MLPrimaryKey represents a primary key entity within a machine learning feature store. Primary keys uniquely identify records in feature tables and are essential for joining features with entities in online and offline feature serving. In feature stores like Feast, Tecton, or AWS SageMaker Feature Store, primary keys define the identifier columns that link features to the entities they describe (e.g., userid, productid, transaction_id).",source:"@site/genDocs/docs/generated/metamodel/entities/mlPrimaryKey-datahub.md",sourceDirName:"docs/generated/metamodel/entities",slug:"/generated/metamodel/entities/mlprimarykey-datahub",permalink:"/docs/generated/metamodel/entities/mlprimarykey-datahub",draft:!1,editUrl:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/mlPrimaryKey-datahub.md",tags:[],version:"current",sidebarPosition:22,frontMatter:{sidebar_position:22,title:"MLPrimaryKey",slug:"/generated/metamodel/entities/mlprimarykey-datahub",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/mlPrimaryKey-datahub.md"},sidebar:"overviewSidebar",previous:{title:"ML Feature",permalink:"/docs/generated/metamodel/entities/mlfeature"},next:{title:"MLPrimaryKey",permalink:"/docs/generated/metamodel/entities/mlprimarykey"}},p={},m=[{value:"Identity",id:"identity",level:2},{value:"Important Capabilities",id:"important-capabilities",level:2},{value:"Primary Key Properties",id:"primary-key-properties",level:3},{value:"Editable Properties",id:"editable-properties",level:3},{value:"Data Lineage",id:"data-lineage",level:3},{value:"Tags and Glossary Terms",id:"tags-and-glossary-terms",level:3},{value:"Ownership",id:"ownership",level:3},{value:"Domains and Data Products",id:"domains-and-data-products",level:3},{value:"Structured Properties",id:"structured-properties",level:3},{value:"Code Examples",id:"code-examples",level:2},{value:"Creating an MLPrimaryKey",id:"creating-an-mlprimarykey",level:3},{value:"Reading MLPrimaryKey Information",id:"reading-mlprimarykey-information",level:3},{value:"Adding MLPrimaryKeys to Feature Tables",id:"adding-mlprimarykeys-to-feature-tables",level:3},{value:"Querying MLPrimaryKey via REST API",id:"querying-mlprimarykey-via-rest-api",level:3},{value:"Integration Points",id:"integration-points",level:2},{value:"Relationship with MLFeatureTable",id:"relationship-with-mlfeaturetable",level:3},{value:"Relationship with Datasets",id:"relationship-with-datasets",level:3},{value:"Relationship with MLFeatures",id:"relationship-with-mlfeatures",level:3},{value:"Search and Discovery",id:"search-and-discovery",level:3},{value:"Platform Instance Support",id:"platform-instance-support",level:3},{value:"Notable Exceptions",id:"notable-exceptions",level:2},{value:"Composite Primary Keys",id:"composite-primary-keys",level:3},{value:"Primary Key vs. Entity Key vs. Join Key",id:"primary-key-vs-entity-key-vs-join-key",level:3},{value:"Primary Keys as Features",id:"primary-keys-as-features",level:3},{value:"Namespace Consistency",id:"namespace-consistency",level:3},{value:"Data Type Evolution",id:"data-type-evolution",level:3},{value:"Primary Keys and Privacy",id:"primary-keys-and-privacy",level:3},{value:"Technical Reference",id:"technical-reference",level:2}],u={toc:m},d="wrapper";function g(e){var{components:t}=e,a=s(e,["components"]);return(0,r.yg)(d,i(function(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{},r=Object.keys(a);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(a).filter((function(e){return Object.getOwnPropertyDescriptor(a,e).enumerable})))),r.forEach((function(t){n(e,t,a[t])}))}return e}({},u,a),{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"mlprimarykey"},"MLPrimaryKey"),(0,r.yg)("p",null,"MLPrimaryKey represents a primary key entity within a machine learning feature store. Primary keys uniquely identify records in feature tables and are essential for joining features with entities in online and offline feature serving. In feature stores like Feast, Tecton, or AWS SageMaker Feature Store, primary keys define the identifier columns that link features to the entities they describe (e.g., ",(0,r.yg)("inlineCode",{parentName:"p"},"user_id"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"product_id"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"transaction_id"),")."),(0,r.yg)("h2",{id:"identity"},"Identity"),(0,r.yg)("p",null,"MLPrimaryKeys are identified by two pieces of information:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Feature Namespace"),": A logical grouping or namespace for the primary key, typically corresponding to a feature table or feature group. This allows for organizational hierarchy and prevents naming conflicts across different feature sets."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Primary Key Name"),": The specific name of the primary key within the namespace. This is the identifier that would be used in the feature store to reference this key.")),(0,r.yg)("p",null,"An example of an MLPrimaryKey identifier is ",(0,r.yg)("inlineCode",{parentName:"p"},"urn:li:mlPrimaryKey:(users_feature_table,user_id)"),"."),(0,r.yg)("p",null,"The URN structure follows this pattern:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"urn:li:mlPrimaryKey:(<feature_namespace>,<primary_key_name>)\n")),(0,r.yg)("p",null,"Where:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"<feature_namespace>")," is the namespace, often matching the feature table name"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"<primary_key_name>")," is the unique name of the primary key")),(0,r.yg)("p",null,"For example:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"urn:li:mlPrimaryKey:(users_feature_table,user_id)")," - User ID in a user features table"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"urn:li:mlPrimaryKey:(product_features,product_id)")," - Product ID in a product features table"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"urn:li:mlPrimaryKey:(transactions,transaction_id)")," - Transaction ID in a transactions feature table")),(0,r.yg)("h2",{id:"important-capabilities"},"Important Capabilities"),(0,r.yg)("h3",{id:"primary-key-properties"},"Primary Key Properties"),(0,r.yg)("p",null,"The core metadata about an MLPrimaryKey is stored in the ",(0,r.yg)("inlineCode",{parentName:"p"},"mlPrimaryKeyProperties")," aspect. This includes:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Description"),": Documentation explaining what this primary key represents, what entities it identifies, and how it should be used in feature serving."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Data Type"),": The data type of the primary key (e.g., TEXT, NUMERIC, BOOLEAN, BYTE, etc.). This corresponds to the MLFeatureDataType enum and helps with validation and type checking during feature serving."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Version"),": A version tag that can track the evolution of the primary key definition over time. This is useful when primary key schemas change or when multiple versions need to coexist."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Sources"),": URN references to upstream dataset entities that this primary key is derived from. This creates lineage connections between your data warehouse tables and your ML feature store, establishing data provenance."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Custom Properties"),": Additional key-value pairs for platform-specific metadata that doesn't fit into standard fields.")),(0,r.yg)("p",null,"The following code snippet shows you how to create an MLPrimaryKey with properties:"),(0,r.yg)("details",null,(0,r.yg)("summary",null,"Python SDK: Create an MLPrimaryKey"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},'import os\n\nimport datahub.emitter.mce_builder as builder\nimport datahub.metadata.schema_classes as models\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\n\n# Create an emitter to DataHub over REST\ngms_server = os.getenv("DATAHUB_GMS_URL", "http://localhost:8080")\ntoken = os.getenv("DATAHUB_GMS_TOKEN")\nemitter = DatahubRestEmitter(gms_server=gms_server, token=token)\n\ndataset_urn = builder.make_dataset_urn(\n    name="fct_users_created", platform="hive", env="PROD"\n)\nprimary_key_urn = builder.make_ml_primary_key_urn(\n    feature_table_name="users_feature_table",\n    primary_key_name="user_id",\n)\n\n#  Create feature\nmetadata_change_proposal = MetadataChangeProposalWrapper(\n    entityUrn=primary_key_urn,\n    aspect=models.MLPrimaryKeyPropertiesClass(\n        description="Represents the id of the user the other features relate to.",\n        # attaching a source to a ml primary key creates lineage between the feature\n        # and the upstream dataset. This is how lineage between your data warehouse\n        # and machine learning ecosystem is established.\n        sources=[dataset_urn],\n        dataType="TEXT",\n    ),\n)\n\n# Emit metadata!\nemitter.emit_mcp(metadata_change_proposal)\nprint(f"Created ML primary key: {primary_key_urn}")\n\n'))),(0,r.yg)("h3",{id:"editable-properties"},"Editable Properties"),(0,r.yg)("p",null,"Like other DataHub entities, MLPrimaryKeys separate ingested metadata from user-edited metadata. The ",(0,r.yg)("inlineCode",{parentName:"p"},"editableMlPrimaryKeyProperties")," aspect allows users to enhance the metadata through the DataHub UI without interfering with automated ingestion:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Description"),": A user-provided description that can supplement or override the description from the ingestion source.")),(0,r.yg)("p",null,"This separation ensures that:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"User edits are preserved across ingestion runs"),(0,r.yg)("li",{parentName:"ul"},"Source system metadata remains authoritative for its fields"),(0,r.yg)("li",{parentName:"ul"},"Documentation can be improved incrementally by data practitioners")),(0,r.yg)("h3",{id:"data-lineage"},"Data Lineage"),(0,r.yg)("p",null,"MLPrimaryKeys support lineage tracking through their ",(0,r.yg)("inlineCode",{parentName:"p"},"sources")," field. By linking primary keys to upstream datasets, you can:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Trace Data Origins"),": Understand which warehouse tables or data sources provide the key values"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Impact Analysis"),": Identify downstream ML models and feature tables affected by changes to source data"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Data Quality Monitoring"),": Track data quality issues from source systems through to feature stores"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Compliance and Auditing"),": Document the complete data flow from raw data to ML features")),(0,r.yg)("p",null,"The lineage relationships created are of type ",(0,r.yg)("inlineCode",{parentName:"p"},"DerivedFrom")," and explicitly marked as lineage relationships (",(0,r.yg)("inlineCode",{parentName:"p"},"isLineage: true"),"), ensuring they appear in DataHub's lineage visualization."),(0,r.yg)("h3",{id:"tags-and-glossary-terms"},"Tags and Glossary Terms"),(0,r.yg)("p",null,"MLPrimaryKeys can have Tags or Terms attached to them through the ",(0,r.yg)("inlineCode",{parentName:"p"},"globalTags")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"glossaryTerms")," aspects. This enables:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Classification"),": Tag primary keys with security classifications (e.g., ",(0,r.yg)("inlineCode",{parentName:"li"},"pii"),", ",(0,r.yg)("inlineCode",{parentName:"li"},"sensitive"),")"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Organization"),": Group related primary keys with project or domain tags"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Business Context"),": Link primary keys to business glossary terms to provide business context")),(0,r.yg)("p",null,"Read ",(0,r.yg)("a",{parentName:"p",href:"https://medium.com/datahub-project/tags-and-terms-two-powerful-datahub-features-used-in-two-different-scenarios-b5b4791e892e"},"this blog")," to understand the difference between tags and terms."),(0,r.yg)("h3",{id:"ownership"},"Ownership"),(0,r.yg)("p",null,"Ownership is associated with an MLPrimaryKey using the ",(0,r.yg)("inlineCode",{parentName:"p"},"ownership")," aspect. Owners can be data scientists, ML engineers, or feature store administrators responsible for maintaining the primary key definition. Ownership helps with:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Accountability"),": Clear ownership for maintaining key definitions"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Access Control"),": Integration with DataHub policies for permission management"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Contact Information"),": Quick identification of who to ask about a primary key")),(0,r.yg)("h3",{id:"domains-and-data-products"},"Domains and Data Products"),(0,r.yg)("p",null,"MLPrimaryKeys support the ",(0,r.yg)("inlineCode",{parentName:"p"},"domains")," aspect, allowing them to be organized into logical business domains or data products. This helps with:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Organizational Structure"),": Group ML assets by team, department, or business unit"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Discovery"),": Filter and search for primary keys within specific domains"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Governance"),": Apply domain-specific policies and ownership models")),(0,r.yg)("h3",{id:"structured-properties"},"Structured Properties"),(0,r.yg)("p",null,"MLPrimaryKeys support the ",(0,r.yg)("inlineCode",{parentName:"p"},"structuredProperties")," aspect, allowing organizations to extend the metadata model with custom fields that are validated and searchable. This enables:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Custom Metadata"),": Add organization-specific fields beyond standard properties"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Validation"),": Enforce data quality on custom metadata"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Advanced Search"),": Filter and search on custom properties")),(0,r.yg)("h2",{id:"code-examples"},"Code Examples"),(0,r.yg)("h3",{id:"creating-an-mlprimarykey"},"Creating an MLPrimaryKey"),(0,r.yg)("details",null,(0,r.yg)("summary",null,"Python SDK: Create an MLPrimaryKey with lineage"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},'import os\n\nimport datahub.emitter.mce_builder as builder\nimport datahub.metadata.schema_classes as models\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\n\n# Create an emitter to DataHub over REST\ngms_server = os.getenv("DATAHUB_GMS_URL", "http://localhost:8080")\ntoken = os.getenv("DATAHUB_GMS_TOKEN")\nemitter = DatahubRestEmitter(gms_server=gms_server, token=token)\n\ndataset_urn = builder.make_dataset_urn(\n    name="fct_users_created", platform="hive", env="PROD"\n)\nprimary_key_urn = builder.make_ml_primary_key_urn(\n    feature_table_name="users_feature_table",\n    primary_key_name="user_id",\n)\n\n#  Create feature\nmetadata_change_proposal = MetadataChangeProposalWrapper(\n    entityUrn=primary_key_urn,\n    aspect=models.MLPrimaryKeyPropertiesClass(\n        description="Represents the id of the user the other features relate to.",\n        # attaching a source to a ml primary key creates lineage between the feature\n        # and the upstream dataset. This is how lineage between your data warehouse\n        # and machine learning ecosystem is established.\n        sources=[dataset_urn],\n        dataType="TEXT",\n    ),\n)\n\n# Emit metadata!\nemitter.emit_mcp(metadata_change_proposal)\nprint(f"Created ML primary key: {primary_key_urn}")\n\n'))),(0,r.yg)("h3",{id:"reading-mlprimarykey-information"},"Reading MLPrimaryKey Information"),(0,r.yg)("details",null,(0,r.yg)("summary",null,"Python SDK: Read MLPrimaryKey using the v2 SDK"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},'from datahub.sdk import DataHubClient, MLPrimaryKeyUrn\n\nclient = DataHubClient.from_env()\n\n# Or get this from the UI (share -> copy urn) and use MLPrimaryKeyUrn.from_string(...)\nmlprimarykey_urn = MLPrimaryKeyUrn("user_features", "user_id")\n\nmlprimarykey_entity = client.entities.get(mlprimarykey_urn)\nprint("MLPrimaryKey name:", mlprimarykey_entity.name)\nprint("MLPrimaryKey feature table:", mlprimarykey_entity.feature_table_urn)\nprint("MLPrimaryKey description:", mlprimarykey_entity.description)\n\n'))),(0,r.yg)("h3",{id:"adding-mlprimarykeys-to-feature-tables"},"Adding MLPrimaryKeys to Feature Tables"),(0,r.yg)("p",null,"MLPrimaryKeys are typically associated with feature tables to define how records should be uniquely identified. A feature table can have one or more primary keys (composite keys)."),(0,r.yg)("details",null,(0,r.yg)("summary",null,"Python SDK: Add primary keys to a feature table"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},'import datahub.emitter.mce_builder as builder\nimport datahub.metadata.schema_classes as models\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.ingestion.graph.client import DatahubClientConfig, DataHubGraph\nfrom datahub.metadata.schema_classes import MLFeatureTablePropertiesClass\n\ngms_endpoint = "http://localhost:8080"\n# Create an emitter to DataHub over REST\nemitter = DatahubRestEmitter(gms_server=gms_endpoint, extra_headers={})\n\nfeature_table_urn = builder.make_ml_feature_table_urn(\n    feature_table_name="users_feature_table", platform="feast"\n)\nprimary_key_urns = [\n    builder.make_ml_primary_key_urn(\n        feature_table_name="users_feature_table",\n        primary_key_name="user_id",\n    ),\n]\n\n# This code concatenates the new primary keys with the existing primary keys in the feature table.\n# If you want to replace all existing primary keys with only the new ones, you can comment out this line.\ngraph = DataHubGraph(DatahubClientConfig(server=gms_endpoint))\nfeature_table_properties = graph.get_aspect(\n    entity_urn=feature_table_urn, aspect_type=MLFeatureTablePropertiesClass\n)\nif feature_table_properties:\n    current_primary_keys = feature_table_properties.mlPrimaryKeys\n    print("current_primary_keys:", current_primary_keys)\n    if current_primary_keys:\n        primary_key_urns += current_primary_keys\n\nfeature_table_properties = models.MLFeatureTablePropertiesClass(\n    mlPrimaryKeys=primary_key_urns\n)\n# MCP creation\nmetadata_change_proposal = MetadataChangeProposalWrapper(\n    entityUrn=feature_table_urn,\n    aspect=feature_table_properties,\n)\n\n# Emit metadata! This is a blocking call\nemitter.emit(metadata_change_proposal)\n\n'))),(0,r.yg)("h3",{id:"querying-mlprimarykey-via-rest-api"},"Querying MLPrimaryKey via REST API"),(0,r.yg)("p",null,"The standard REST APIs can be used to retrieve MLPrimaryKey metadata and relationships."),(0,r.yg)("details",null,(0,r.yg)("summary",null,"REST API: Fetch MLPrimaryKey entity information"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},'import json\nimport urllib.parse\n\nimport requests\n\n# Configuration\ngms_server = "http://localhost:8080"\nprimary_key_urn = "urn:li:mlPrimaryKey:(users_feature_table,user_id)"\n\n# Encode the URN for use in URL\nencoded_urn = urllib.parse.quote(primary_key_urn, safe="")\n\n# Fetch the MLPrimaryKey entity\nresponse = requests.get(f"{gms_server}/entities/{encoded_urn}")\n\nif response.status_code == 200:\n    entity_data = response.json()\n    print("MLPrimaryKey Entity:")\n    print(json.dumps(entity_data, indent=2))\n\n    # Extract specific aspects\n    if "aspects" in entity_data:\n        aspects = entity_data["aspects"]\n\n        # Get mlPrimaryKeyProperties\n        if "mlPrimaryKeyProperties" in aspects:\n            properties = aspects["mlPrimaryKeyProperties"]["value"]\n            print("\\nPrimary Key Properties:")\n            print(f"  Description: {properties.get(\'description\', \'N/A\')}")\n            print(f"  Data Type: {properties.get(\'dataType\', \'N/A\')}")\n            if "sources" in properties:\n                print(f"  Sources: {properties[\'sources\']}")\n\n        # Get ownership\n        if "ownership" in aspects:\n            ownership = aspects["ownership"]["value"]\n            print("\\nOwnership:")\n            for owner in ownership.get("owners", []):\n                print(f"  - {owner[\'owner\']} ({owner[\'type\']})")\n\n        # Get tags\n        if "globalTags" in aspects:\n            tags = aspects["globalTags"]["value"]\n            print("\\nTags:")\n            for tag in tags.get("tags", []):\n                print(f"  - {tag[\'tag\']}")\n\n        # Get glossary terms\n        if "glossaryTerms" in aspects:\n            terms = aspects["glossaryTerms"]["value"]\n            print("\\nGlossary Terms:")\n            for term in terms.get("terms", []):\n                print(f"  - {term[\'urn\']}")\nelse:\n    print(f"Failed to fetch entity. Status code: {response.status_code}")\n    print(f"Response: {response.text}")\n\n# Find feature tables that use this primary key\n# Query for entities with a KeyedBy relationship to this primary key\nrelationships_response = requests.get(\n    f"{gms_server}/relationships",\n    params={\n        "direction": "INCOMING",\n        "urn": primary_key_urn,\n        "types": "KeyedBy",\n    },\n)\n\nif relationships_response.status_code == 200:\n    relationships_data = relationships_response.json()\n    print("\\n\\nFeature Tables using this Primary Key:")\n    for relationship in relationships_data.get("relationships", []):\n        print(f"  - {relationship[\'entity\']}")\nelse:\n    print(\n        f"\\nFailed to fetch relationships. Status code: {relationships_response.status_code}"\n    )\n\n# Find upstream datasets that this primary key is derived from\nupstream_response = requests.get(\n    f"{gms_server}/relationships",\n    params={\n        "direction": "OUTGOING",\n        "urn": primary_key_urn,\n        "types": "DerivedFrom",\n    },\n)\n\nif upstream_response.status_code == 200:\n    upstream_data = upstream_response.json()\n    print("\\nUpstream Datasets (Sources):")\n    for relationship in upstream_data.get("relationships", []):\n        print(f"  - {relationship[\'entity\']}")\nelse:\n    print(\n        f"\\nFailed to fetch upstream lineage. Status code: {upstream_response.status_code}"\n    )\n\n'))),(0,r.yg)("h2",{id:"integration-points"},"Integration Points"),(0,r.yg)("h3",{id:"relationship-with-mlfeaturetable"},"Relationship with MLFeatureTable"),(0,r.yg)("p",null,"The most important relationship for MLPrimaryKeys is with MLFeatureTables. Feature tables reference primary keys through their ",(0,r.yg)("inlineCode",{parentName:"p"},"mlPrimaryKeyProperties")," aspect, creating a ",(0,r.yg)("inlineCode",{parentName:"p"},"KeyedBy")," relationship. This relationship indicates that:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"The feature table uses these primary key(s) to uniquely identify records"),(0,r.yg)("li",{parentName:"ul"},"When serving features, these keys are used for lookups and joins"),(0,r.yg)("li",{parentName:"ul"},"Multiple primary keys on a table form a composite key")),(0,r.yg)("p",null,"This bidirectional relationship enables:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Forward Navigation"),": From a feature table, see all its primary keys"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Reverse Navigation"),": From a primary key, see all feature tables that use it"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Reusability"),": The same primary key can be shared across multiple feature tables")),(0,r.yg)("h3",{id:"relationship-with-datasets"},"Relationship with Datasets"),(0,r.yg)("p",null,"MLPrimaryKeys can be linked to Dataset entities through the ",(0,r.yg)("inlineCode",{parentName:"p"},"sources")," field in ",(0,r.yg)("inlineCode",{parentName:"p"},"mlPrimaryKeyProperties"),". This creates ",(0,r.yg)("inlineCode",{parentName:"p"},"DerivedFrom")," lineage relationships to upstream data warehouse tables, establishing:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Data Provenance"),": Track where primary key values originate"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Impact Analysis"),": Understand how changes to source tables affect the feature store"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Cross-Platform Lineage"),": Connect data warehouse assets to ML platform assets")),(0,r.yg)("h3",{id:"relationship-with-mlfeatures"},"Relationship with MLFeatures"),(0,r.yg)("p",null,"While not a direct relationship, MLPrimaryKeys and MLFeatures both belong to the same feature namespace (typically a feature table). Primary keys identify the entity, while features provide the attributes of that entity. Together, they form the complete feature table schema."),(0,r.yg)("h3",{id:"search-and-discovery"},"Search and Discovery"),(0,r.yg)("p",null,"MLPrimaryKeys are fully indexed for search with the following capabilities:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Name Search"),": The primary key name is indexed with autocomplete support and high relevance boosting"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Namespace Search"),": The feature namespace is searchable with partial matching"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Description Search"),": Full-text search on descriptions (when present)"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Relationship Search"),": Find primary keys by their associated feature tables or source datasets")),(0,r.yg)("h3",{id:"platform-instance-support"},"Platform Instance Support"),(0,r.yg)("p",null,"MLPrimaryKeys support the ",(0,r.yg)("inlineCode",{parentName:"p"},"dataPlatformInstance")," aspect, which is useful when:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Multiple feature store instances exist (e.g., dev, staging, prod)"),(0,r.yg)("li",{parentName:"ul"},"The same logical primary key exists in different environments"),(0,r.yg)("li",{parentName:"ul"},"Organizations need to track metadata separately per instance")),(0,r.yg)("h2",{id:"notable-exceptions"},"Notable Exceptions"),(0,r.yg)("h3",{id:"composite-primary-keys"},"Composite Primary Keys"),(0,r.yg)("p",null,"When a feature table requires multiple columns to uniquely identify a record, it uses composite primary keys. In DataHub:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Create separate MLPrimaryKey entities for each column in the composite key"),(0,r.yg)("li",{parentName:"ul"},"Link all of them to the feature table via the ",(0,r.yg)("inlineCode",{parentName:"li"},"mlPrimaryKeys")," array in ",(0,r.yg)("inlineCode",{parentName:"li"},"MLFeatureTableProperties")),(0,r.yg)("li",{parentName:"ul"},"The order in the array may be significant for some feature stores (e.g., for indexing optimization)")),(0,r.yg)("p",null,"Example:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},'# For a feature table keyed by (user_id, date)\nprimary_keys = [\n    "urn:li:mlPrimaryKey:(daily_user_features,user_id)",\n    "urn:li:mlPrimaryKey:(daily_user_features,date)"\n]\n')),(0,r.yg)("h3",{id:"primary-key-vs-entity-key-vs-join-key"},"Primary Key vs. Entity Key vs. Join Key"),(0,r.yg)("p",null,"Different feature stores use different terminology:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Feast"),': Uses "entity" to refer to what DataHub calls a primary key'),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Tecton"),': Uses "entity keys" and "join keys"'),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"SageMaker Feature Store"),': Uses "record identifier"'),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Databricks Feature Store"),': Uses "primary keys"')),(0,r.yg)("p",null,"DataHub normalizes these concepts under the ",(0,r.yg)("inlineCode",{parentName:"p"},"mlPrimaryKey")," entity type. When ingesting from different platforms, connectors map these platform-specific terms to MLPrimaryKey."),(0,r.yg)("h3",{id:"primary-keys-as-features"},"Primary Keys as Features"),(0,r.yg)("p",null,"In some feature stores, primary keys can also serve as features themselves (e.g., using ",(0,r.yg)("inlineCode",{parentName:"p"},"user_id")," as both the key and a feature for training). In DataHub:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Create both an MLPrimaryKey entity for the identifier role"),(0,r.yg)("li",{parentName:"ul"},"Create an MLFeature entity for the feature role"),(0,r.yg)("li",{parentName:"ul"},"Both can reference the same source dataset column")),(0,r.yg)("p",null,"This dual representation accurately reflects the different roles the same data plays in the feature store."),(0,r.yg)("h3",{id:"namespace-consistency"},"Namespace Consistency"),(0,r.yg)("p",null,"The feature namespace in an MLPrimaryKey URN should typically match the feature table name where it's used. However, DataHub doesn't enforce this requirement, allowing for flexibility in cases where:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Primary keys are shared across multiple feature tables"),(0,r.yg)("li",{parentName:"ul"},"Organizations use different namespacing schemes"),(0,r.yg)("li",{parentName:"ul"},"Platform-specific naming conventions differ from logical groupings")),(0,r.yg)("h3",{id:"data-type-evolution"},"Data Type Evolution"),(0,r.yg)("p",null,"Primary key data types should remain stable to avoid breaking feature serving. However, if a type change is necessary:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Consider creating a new MLPrimaryKey with a versioned name"),(0,r.yg)("li",{parentName:"ul"},"Use the ",(0,r.yg)("inlineCode",{parentName:"li"},"version")," field to track the schema evolution"),(0,r.yg)("li",{parentName:"ul"},"Maintain both old and new primary keys during migration periods"),(0,r.yg)("li",{parentName:"ul"},"Update feature tables to reference the new primary key once migration is complete")),(0,r.yg)("h3",{id:"primary-keys-and-privacy"},"Primary Keys and Privacy"),(0,r.yg)("p",null,"Primary keys often contain or directly map to personally identifiable information (PII). Organizations should:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Apply appropriate tags (e.g., ",(0,r.yg)("inlineCode",{parentName:"li"},"pii"),", ",(0,r.yg)("inlineCode",{parentName:"li"},"gdpr_sensitive"),") to MLPrimaryKey entities"),(0,r.yg)("li",{parentName:"ul"},"Document any hashing or encryption applied to key values"),(0,r.yg)("li",{parentName:"ul"},"Use DataHub policies to control who can view primary key metadata"),(0,r.yg)("li",{parentName:"ul"},"Link to upstream dataset entities that may have additional privacy metadata")),(0,r.yg)("h2",{id:"technical-reference"},"Technical Reference"),(0,r.yg)("p",null,"For technical details about fields, searchability, and relationships, view the ",(0,r.yg)("strong",{parentName:"p"},"Columns")," tab in DataHub."))}g.isMDXComponent=!0}}]);